package uk.ac.ox.comlab.oxpath.oxpathTreeWalker;

import static uk.ac.ox.comlab.oxpath.oxpathTreeWalker.OXPathType.OXPathTypes.NODESET;
import uk.ac.ox.comlab.oxpath.BadDataException;
import uk.ac.ox.comlab.oxpath.benchmark.BenchFactory;
import uk.ac.ox.comlab.oxpath.benchmark.BenchMarker;

import com.gargoylesoftware.htmlunit.html.DomNode;

/**
 * Class for representing OXPathDomNode.  Acts as a wrapper for HtmlUnit's DomNode (and its child) decorating with parent marker and current marker references
 * @author AndrewJSel
 *
 */
public class OXPathDomNode {
	
	/**
	 * Constructor for the class.  Object "glues" together a DomNode in HtmlUnit's implementation, a reference to the parent marker,
	 *  and a reference to the last marker used
	 * @param iNode DomNode in HtmlUnit to use
	 * @param iParent reference to parent marker
	 * @param iLast reference to current marker
	 */
	public OXPathDomNode(DomNode iNode, int iParent, int iLast) {
		node = iNode;
		parent = iParent;
		last = iLast;
	}
	
	/**
	 * Gets the object node
	 * @return the DomNode
	 */
	public DomNode getNode() {
		return node;
	}
	
	/**
	 * Gets the reference to the parent marker
	 * @return reference to the parent marker
	 */
	public int getParent() {
		return parent;
	}
	
	/**
	 * Gets the reference to the last marker
	 * @return reference to the last marker
	 */
	public int getLast() {
		return last;
	}
	
	@Override
	public String toString() {
		return (this.getClass()+ "[" + this.getNode()+", " +this.getParent()+", " +this.getLast() + "]");
	}
	
//	@Override
//	public boolean equals(Object obj) {
//		if (!(obj instanceof OXPathDomNode)) return false;
//		else {
//			OXPathDomNode that = (OXPathDomNode) obj; 
//			return ((this.getNode().equals(that.getNode()))&&(this.getParent()==that.getParent())&&(this.getLast()==that.getLast())) ? true : false;
//		}
//	}
	
	
	
	/**
	 * Returns the node by calling the getByXPath in HtmlUnit.  Only use when return value is an XPath nodeset data type
	 * @param stepString xpath query as a String
	 * @param forward true for forward navigation, false otherwise
	 * @return OXPathNodeList with all relevant nodes
	 * @throws BadDataException in case of error on adding nodes to the list (return value of xpath call is not a nodelist)
	 */
	public OXPathNodeList<OXPathDomNode> getByXPath(String stepString,
			boolean forward) throws BadDataException {
		OXPathNodeList<OXPathDomNode> result = new OXPathNodeList<OXPathDomNode>();
		BenchMarker xalanOverhead = BenchFactory.newBenchMarker("xalanOverhead");
		xalanOverhead.start();
		DomNode iC = this.getNode();
		//since we are passing in XPath, no extraction are encountered, so parent and current are the same
		OXPathType iResult = new OXPathType(iC.getByXPath(stepString), this.getParent(), this.getLast());
		if (iResult.isType().equals(NODESET)) {
			result.addList(iResult.nodeList());
		}
		xalanOverhead.finish();
		return result;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + last;
		result = prime * result + ((node == null) ? 0 : node.hashCode());
		result = prime * result + parent;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		OXPathDomNode other = (OXPathDomNode) obj;
		if (last != other.last)
			return false;
		if (node == null) {
			if (other.node != null)
				return false;
		} else if (!node.equals(other.node))
			return false;
		if (parent != other.parent)
			return false;
		return true;
	}

	/**
	 * instance field storing the node
	 */
	private DomNode node;
	/**
	 * instance field storing the reference to the parent marker
	 */
	private int parent;
	/**
	 * instance field storing the reference to the current marker
	 */
	private int last;

}
