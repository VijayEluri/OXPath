/* Generated By:JJTree&JavaCC: Do not edit this line. OXPathScripter.java */
package uk.ac.ox.comlab.oxpath.scriptParser;

import java.io.FileReader;

import java.lang.StringBuilder;

import java.io.StringReader;

import uk.ac.ox.comlab.oxpath.BadDataException;

public class OXPathScripter/*@bgen(jjtree)*/implements OXPathScripterTreeConstants, OXPathScripterConstants {/*@bgen(jjtree)*/
  protected JJTOXPathScripterState jjtree = new JJTOXPathScripterState();public OXPathScripter()
  {

  }

//use as a testing environment
  public static void main(String args [])
  {

//    System.out.println("Reading from standard input...");//    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");    try
    {
      FileReader reader = new FileReader(args[0]);
//      new OXPathScripter(reader);
      OXPathScripter oxpathscripter = new OXPathScripter(reader);
      SimpleNode n = oxpathscripter.Script();
//      OXPathScripter.dump(n,"");//      System.out.println("Thank you.");    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

   /**
   * Returns JJTree of script
   */
   public static SimpleNode getJJTree(String inputfile) throws Exception
           {
//	     SimpleNode n;
//	     try//	     {               FileReader reader = new FileReader(inputfile);
               OXPathScripter oxpathscripter = new OXPathScripter(reader);
               SimpleNode n = oxpathscripter.Script();
               return n;
//	     }
//	     catch (Exception e)//	     {//      System.out.println("Oops.");//      System.out.println(e.getMessage());//      e.printStackTrace();
//     }
           }

           public static SimpleNode getJJTreeFromString(String in) throws Exception
           {
                      return new OXPathScripter(new StringReader(in)).Script();
           }

           protected static String process(SimpleNode n, String value)
           {
             n.jjtSetValue(value);
             return (String) n.jjtGetValue();
           }

           public static String getValue(SimpleNode n) throws RuntimeException
           {
             if (n.jjtGetValue() instanceof String)
             {
               return (String) n.jjtGetValue();
             }
             else throw new RuntimeException("Node value state not String object!");
           }

           public static void dump(SimpleNode root, String prefix) {
            if (!(root.jjtGetValue() instanceof String))
              {System.out.println(root.toString(prefix));}
            else
              System.out.println(root.toString(prefix)+ "["+root.jjtGetValue()+"]");
    if (root.jjtGetNumChildren() > 0) {
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          dump(n,prefix + " ");
        }
      }
    }
  }

  public static String stringDump(SimpleNode root, String prefix)
  {
    return stringDumpInt(root,prefix).toString();
  }

  public static StringBuilder stringDumpInt(SimpleNode root, String prefix)
  {
    StringBuilder rv = new StringBuilder();
    if (!(root.jjtGetValue() instanceof String))
              {rv.append(root.toString(prefix) + "\u005cn");}
            else
              {rv.append(root.toString(prefix)+ "["+root.jjtGetValue()+"]\u005cn");}
            if (root.jjtGetNumChildren() > 0) {
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          rv.append(stringDumpInt(n,prefix + " "));
        }
      }
    }
    return rv;
  }

           public static SimpleNode safeGetChild(SimpleNode parent, int index) throws BadDataException {
     if (isSafeChild(parent,index))
     {
       return (SimpleNode) parent.jjtGetChild(index);
     }
     else throw new BadDataException("Not an OXPath AST node!");
           }

           public static boolean isSafeChild(SimpleNode parent, int index) {
             if (parent.jjtGetChild(index) instanceof SimpleNode)
             {
               return true;
             }
             else
             {
               return false;
             }
           }

           public static boolean hasChildByName(SimpleNode parent, String name)
           {
             for (int i = 0; i<parent.jjtGetNumChildren(); i++)
             {
               if (parent.jjtGetChild(i).toString().equals(name))
               {
                 return true;
               }
     }
     return false;
           }

                public static boolean hasDescendantOrSelfByName(SimpleNode parent, String name) throws BadDataException
           {
             if (parent.toString().equals(name)) return true;
             else
             {
               for (int i = 0; i<parent.jjtGetNumChildren(); i++)
                   {
                      if (hasDescendantOrSelfByName(toSimpleNode(parent.jjtGetChild(i)),name)) {
                          return true;
                      }
           }
     }
     return false;
           }

           public static SimpleNode getChildByName(SimpleNode parent, String name) throws BadDataException
           {
             for (int i = 0; i<parent.jjtGetNumChildren(); i++)
             {
               if (parent.jjtGetChild(i).toString().equals(name))
               {
                 return safeGetChild(parent,i);
               }
     }
     throw new BadDataException("Child not found!");
           }

                           public static int test(String tester)
                           {
                    System.out.println(tester);
    return 1;
   }

   public static boolean isDescendant(Node a, Node d)
   {
     if (a.equals(d)) return true;
     Node temp = d.jjtGetParent();
         while (!(temp==null))
         {
             if (a.equals(temp)) return true;
             temp = temp.jjtGetParent();
         }
         return false;
   }

   public static int getNodeID(SimpleNode node)
   {
     return node.id;
   }

   public static SimpleNode toSimpleNode(Node n) throws BadDataException
   {
    if (n instanceof SimpleNode) return (SimpleNode) n;
    else throw new BadDataException("Node can't be cast as a SimpleNode");
  }

//SimpleNode Start() ://{}//{//  Script()//  {//    return jjtThis;//  }//}
  final public SimpleNode Script() throws ParseException {
 /*@bgen(jjtree) Script */
  SimpleNode jjtn000 = new SimpleNode(JJTSCRIPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PATH:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        PathDeclaration();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Declarations() throws ParseException {
 /*@bgen(jjtree) Declarations */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATABASE:
        case URL:
        case VARIABLE_DEFAULT:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATABASE:
          DatabaseDeclaration();
          break;
        case URL:
          URLDeclaration();
          break;
        case VARIABLE_DEFAULT:
        case VARIABLE:
          VariableDeclaration();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_3:
      while (true) {
        PathDeclaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PATH:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void XQDeclarations() throws ParseException {
 /*@bgen(jjtree) XQDeclarations */
  SimpleNode jjtn000 = new SimpleNode(JJTXQDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_4:
      while (true) {
        ScrapeDeclaration();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QNAME_DEFAULT:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_4;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void DatabaseDeclaration() throws ParseException {
    jj_consume_token(DATABASE);
    DatabaseFileName();
    jj_consume_token(ENDLINE);
  }

  final public void DatabaseFileName() throws ParseException {
 /*@bgen(jjtree) DatabaseFileName */
 SimpleNode jjtn000 = new SimpleNode(JJTDATABASEFILENAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String subtree;
    try {
      //  Letter() ( Letter() | < DIGIT > | < PLUS > | < UNDERSCORE > | < TILDE > )* < DBNAMEEXT >
                subtree = XPathLiteral();
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            process(jjtn000,subtree);
    } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte000;}
            }
            if (jjte000 instanceof ParseException) {
              {if (true) throw (ParseException)jjte000;}
            }
            {if (true) throw (Error)jjte000;}
    } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
    }
  }

  final public String Letter() throws ParseException {
 /*@bgen(jjtree) Letter */
 SimpleNode jjtn000 = new SimpleNode(JJTLETTER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UPPER_ALPHA:
        t = jj_consume_token(UPPER_ALPHA);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,t.image);}
        break;
      case LOWER_ALPHA:
        t = jj_consume_token(LOWER_ALPHA);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                          {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public void URLDeclaration() throws ParseException {
    jj_consume_token(URL);
    URLName();
    jj_consume_token(ENDLINE);
  }

  final public String URLName() throws ParseException {
 /*@bgen(jjtree) URLName */
 SimpleNode jjtn000 = new SimpleNode(JJTURLNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String sp;
 String hp;
 Token t1;
 String up;
 Token t2;
 String us;
    try {
      //adapted from w3c BNF grammar for BNF located @ http://www.w3.org/Addressing/URL/5_BNF.html#z18
        sp = SupportedProtocols();
      hp = HostPort();
                                             sb.append(sp); sb.append(hp);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH_URL:
        t1 = jj_consume_token(SLASH_URL);
        up = URLPath();
                                        sb.append(t1.image); sb.append(up);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUESTION_URL:
        t2 = jj_consume_token(QUESTION_URL);
        us = URLSearch();
                                            sb.append(t2.image); sb.append(us);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String SupportedProtocols() throws ParseException {
 /*@bgen(jjtree) SupportedProtocols */
 SimpleNode jjtn000 = new SimpleNode(JJTSUPPORTEDPROTOCOLS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      //current supported protocols of http and https
        t = jj_consume_token(PROTOCOL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String HostPort() throws ParseException {
 /*@bgen(jjtree) HostPort */
 SimpleNode jjtn000 = new SimpleNode(JJTHOSTPORT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String h;
 Token t;
 String p;
    try {
      h = Host();
              sb.append(h);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        t = jj_consume_token(COLON);
        p = Port();
                                                         sb.append(t.image); sb.append(p);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Host() throws ParseException {
 /*@bgen(jjtree) Host */
 SimpleNode jjtn000 = new SimpleNode(JJTHOST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String subtree;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOWER_ALPHA:
      case UPPER_ALPHA:
        subtree = HostName();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return process(jjtn000,subtree);}
        break;
      case DIGIT:
        subtree = HostNumber();
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                               {if (true) return process(jjtn000,subtree);}
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String HostName() throws ParseException {
 /*@bgen(jjtree) HostName */
 SimpleNode jjtn000 = new SimpleNode(JJTHOSTNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String subtree;
    try {
      subtree = URLIAlpha();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return process(jjtn000,subtree);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLIAlpha() throws ParseException {
 /*@bgen(jjtree) URLIAlpha */
 SimpleNode jjtn000 = new SimpleNode(JJTURLIALPHA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder st = new StringBuilder();
 String l;
 String u;
    try {
      l = Letter();
              st.append(l);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case APOSTROPHE_URL:
      case QUOTE_URL:
      case MINUS_URL:
      case UNDERSCORE_URL:
      case PERIOD_URL:
      case AMPERSAND_URL:
      case EQUALS_URL:
      case DOLLAR_URL:
      case PERCENT_URL:
      case AT_URL:
      case PLUS_URL:
      case EXCLAIMATION_URL:
      case STAR_URL:
      case OPEN_PARAN_URL:
      case CLOSE_PARAN_URL:
      case COMMA_URL:
      case LOWER_ALPHA:
      case UPPER_ALPHA:
      case DIGIT:
        u = URLXAlphas();
                                               st.append(u);
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,st.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLXAlphas() throws ParseException {
 /*@bgen(jjtree) URLXAlphas */
 SimpleNode jjtn000 = new SimpleNode(JJTURLXALPHAS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String u;
 String us;
    try {
      u = URLXAlpha();
                  sb.append(u);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case APOSTROPHE_URL:
      case QUOTE_URL:
      case MINUS_URL:
      case UNDERSCORE_URL:
      case PERIOD_URL:
      case AMPERSAND_URL:
      case EQUALS_URL:
      case DOLLAR_URL:
      case PERCENT_URL:
      case AT_URL:
      case PLUS_URL:
      case EXCLAIMATION_URL:
      case STAR_URL:
      case OPEN_PARAN_URL:
      case CLOSE_PARAN_URL:
      case COMMA_URL:
      case LOWER_ALPHA:
      case UPPER_ALPHA:
      case DIGIT:
        us = URLXAlphas();
                                                      sb.append(us);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
  {if (true) return process(jjtn000,(sb.toString()));}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLXAlpha() throws ParseException {
 /*@bgen(jjtree) URLXAlpha */
 SimpleNode jjtn000 = new SimpleNode(JJTURLXALPHA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
 Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOWER_ALPHA:
      case UPPER_ALPHA:
        s = Letter();
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                      {if (true) return process(jjtn000,s);}
        break;
      case DIGIT:
        t = jj_consume_token(DIGIT);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       {if (true) return process(jjtn000,t.image);}
        break;
      case MINUS_URL:
      case UNDERSCORE_URL:
      case PERIOD_URL:
      case AMPERSAND_URL:
      case EQUALS_URL:
      case DOLLAR_URL:
      case AT_URL:
      case PLUS_URL:
        s = URLSafe();
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       {if (true) return process(jjtn000,s);}
        break;
      case APOSTROPHE_URL:
      case QUOTE_URL:
      case EXCLAIMATION_URL:
      case STAR_URL:
      case OPEN_PARAN_URL:
      case CLOSE_PARAN_URL:
      case COMMA_URL:
        s = URLExtra();
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,s);}
        break;
      case PERCENT_URL:
        s = URLEscape();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return process(jjtn000,s);}
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte000;}
            }
            if (jjte000 instanceof ParseException) {
              {if (true) throw (ParseException)jjte000;}
            }
            {if (true) throw (Error)jjte000;}
    } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLSafe() throws ParseException {
 /*@bgen(jjtree) URLSafe */
 SimpleNode jjtn000 = new SimpleNode(JJTURLSAFE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOLLAR_URL:
        t = jj_consume_token(DOLLAR_URL);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    {if (true) return process(jjtn000,t.image);}
        break;
      case MINUS_URL:
        t = jj_consume_token(MINUS_URL);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   {if (true) return process(jjtn000,t.image);}
        break;
      case UNDERSCORE_URL:
        t = jj_consume_token(UNDERSCORE_URL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,t.image);}
        break;
      case AT_URL:
        t = jj_consume_token(AT_URL);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                {if (true) return process(jjtn000,t.image);}
        break;
      case PERIOD_URL:
        t = jj_consume_token(PERIOD_URL);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    {if (true) return process(jjtn000,t.image);}
        break;
      case AMPERSAND_URL:
        t = jj_consume_token(AMPERSAND_URL);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       {if (true) return process(jjtn000,t.image);}
        break;
      case PLUS_URL:
        t = jj_consume_token(PLUS_URL);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,t.image);}
        break;
      case EQUALS_URL:
        t = jj_consume_token(EQUALS_URL);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLExtra() throws ParseException {
 /*@bgen(jjtree) URLExtra */
 SimpleNode jjtn000 = new SimpleNode(JJTURLEXTRA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCLAIMATION_URL:
        t = jj_consume_token(EXCLAIMATION_URL);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                          {if (true) return process(jjtn000,t.image);}
        break;
      case STAR_URL:
        t = jj_consume_token(STAR_URL);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,t.image);}
        break;
      case QUOTE_URL:
        t = jj_consume_token(QUOTE_URL);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   {if (true) return process(jjtn000,t.image);}
        break;
      case APOSTROPHE_URL:
        t = jj_consume_token(APOSTROPHE_URL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,t.image);}
        break;
      case OPEN_PARAN_URL:
        t = jj_consume_token(OPEN_PARAN_URL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,t.image);}
        break;
      case CLOSE_PARAN_URL:
        t = jj_consume_token(CLOSE_PARAN_URL);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return process(jjtn000,t.image);}
        break;
      case COMMA_URL:
        t = jj_consume_token(COMMA_URL);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLEscape() throws ParseException {
 /*@bgen(jjtree) URLEscape */
 SimpleNode jjtn000 = new SimpleNode(JJTURLESCAPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(PERCENT_URL);
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                     {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String HostNumber() throws ParseException {
 /*@bgen(jjtree) HostNumber */
 SimpleNode jjtn000 = new SimpleNode(JJTHOSTNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s1;
 Token t1;
 String s2;
 Token t2;
 String s3;
 Token t3;
 String s4;
    try {
      s1 = Digits();
      t1 = jj_consume_token(PERIOD_URL);
      s2 = Digits();
      t2 = jj_consume_token(PERIOD_URL);
      s3 = Digits();
      t3 = jj_consume_token(PERIOD_URL);
      s4 = Digits();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   StringBuilder sb = new StringBuilder();
   sb.append(s1);
   sb.append(t1);
   sb.append(s2);
   sb.append(t2);
   sb.append(s3);
   sb.append(t3);
   sb.append(s4);
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Digits() throws ParseException {
 /*@bgen(jjtree) Digits */
 SimpleNode jjtn000 = new SimpleNode(JJTDIGITS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
 StringBuilder sb = new StringBuilder();
    try {
      label_5:
      while (true) {
        t = jj_consume_token(DIGIT);
                 sb.append(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGIT:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_5;
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Port() throws ParseException {
 /*@bgen(jjtree) Port */
 SimpleNode jjtn000 = new SimpleNode(JJTPORT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = Digits();
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
              process(jjtn000,s); {if (true) return getValue(jjtn000);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLPath() throws ParseException {
 /*@bgen(jjtree) URLPath */
 SimpleNode jjtn000 = new SimpleNode(JJTURLPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case APOSTROPHE_URL:
      case QUOTE_URL:
      case MINUS_URL:
      case UNDERSCORE_URL:
      case PERIOD_URL:
      case AMPERSAND_URL:
      case EQUALS_URL:
      case DOLLAR_URL:
      case PERCENT_URL:
      case AT_URL:
      case PLUS_URL:
      case EXCLAIMATION_URL:
      case STAR_URL:
      case OPEN_PARAN_URL:
      case CLOSE_PARAN_URL:
      case COMMA_URL:
      case LOWER_ALPHA:
      case UPPER_ALPHA:
      case DIGIT:
        s1 = URLSegment();
                    sb.append(s1);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SLASH_URL:
          t = jj_consume_token(SLASH_URL);
          s2 = URLPath();
                                                                    sb.append(t.image); sb.append(s2);
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,(sb.toString()));}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLSegment() throws ParseException {
 /*@bgen(jjtree) URLSegment */
 SimpleNode jjtn000 = new SimpleNode(JJTURLSEGMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = URLXAlphas();
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLSearch() throws ParseException {
 /*@bgen(jjtree) URLSearch */
 SimpleNode jjtn000 = new SimpleNode(JJTURLSEARCH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = URLXAlphas();
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode VariableDeclaration() throws ParseException {
 /*@bgen(jjtree) VariableDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      VariableName();
      jj_consume_token(EQUALS_DEFAULT);
      OXPathPathSegment();
      jj_consume_token(ENDLINE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String VariableName() throws ParseException {
 /*@bgen(jjtree) VariableName */
 SimpleNode jjtn000 = new SimpleNode(JJTVARIABLENAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        t = jj_consume_token(VARIABLE);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,t.image);}
        break;
      case VARIABLE_DEFAULT:
        t = jj_consume_token(VARIABLE_DEFAULT);
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                            {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public void PathDeclaration() throws ParseException {
 /*@bgen(jjtree) PathDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTPATHDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(PATH);
      OXPathPathSegment();
      jj_consume_token(ENDLINE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//void OXPathURL() #void://{}//{//  < PATH_URL >  URLName()  < END_URL > //}

//void OXPathPathSegmentEntry() ://{Token t1;// String s1;// String s2;// Token t2;// Token t3;// String s3;// StringBuilder sb = new StringBuilder();// }//{//replaces OXPathPathSegment for initial entry//  (//    ( ( t1=< SLASH > s1=RelativeOXPathLocationPath() {sb.append(t1.image); sb.append(s1);})? t2=< END_PATH > {sb.append(t2.image);}) // <END_PATH > Token distributed inside choice so that no empty choice occurs//   | (s1=AbbreviatedAbsoluteOXPathLocationPath() t2=< END_PATH > {sb.append(s1); sb.append(t2.image);})//  )//  s2=OXPathTerminal() {sb.append(s2);}//  ( (t3=< SLASH > {sb.append(t3.image);} (s3=RelativeOXPathLocationPath() {sb.append(s3);})? ) | s3=AbbreviatedAbsoluteOXPathLocationPath() {sb.append(s3);})//  {process(jjtThis,sb.toString());}//}////String OXPathTerminal() ://{StringBuilder sb = new StringBuilder();// String s;// Token t1;// Token t2;// Token t3;}//{//  t1=< XQ > {sb.append(t1.image);} [ t2=< WHILE > s=XPathQName() {sb.append(t2.image); sb.append(s);}] t3=< GREATER > {sb.append(t3.image);}//  {return process(jjtThis,sb.toString());}//}
  final public String OXPathPathSegment() throws ParseException {
 /*@bgen(jjtree) #OXPathPathSegment(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHPATHSEGMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s;
 Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_DEFAULT:
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case OPEN_CURLY:
      case OXPATH_AXISNAME:
      case XPATH_FORWARD_AXISNAME:
      case XPATH_BACKWARD_AXISNAME:
      case NODE_TYPE:
      case NODE_TYPE_OXPATH:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case VARIABLE:
      case WILDCARD:
      case WILDCARD_BOUNDED:
      case QNAME:
        s = RelativeOXPathLocationPath();
                                   sb.append(s);
        break;
      case SLASH:
        //    < SLASH >  (LOOKAHEAD(2) RelativeOXPathLocationPath())?
                              t = jj_consume_token(SLASH);
                                   sb.append(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARIABLE_DEFAULT:
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case OPEN_CURLY:
        case OXPATH_AXISNAME:
        case XPATH_FORWARD_AXISNAME:
        case XPATH_BACKWARD_AXISNAME:
        case NODE_TYPE:
        case NODE_TYPE_OXPATH:
        case PERIOD:
        case PARENT_SHORT:
        case AT:
        case VARIABLE:
        case WILDCARD:
        case WILDCARD_BOUNDED:
        case QNAME:
          s = RelativeOXPathLocationPath();
                                                                                         sb.append(s);
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
        break;
      case DESCENDENT_OR_SELF_SHORT:
        s = AbbreviatedAbsoluteOXPathLocationPath();
                                             sb.append(s);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,(sb.toString()));}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String RelativeOXPathLocationPath() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
 SimpleNode jjtn000 = new SimpleNode(JJTRELATIVEOXPATHLOCATIONPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s2;
 Token t;
 String s3;
 String s4;
    try {
      s1 = OXPathStep();
                   sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN_KLEENE_STAR:
        s2 = OXPathKleeneStar();
                                                           sb.append(s2);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SLASH:
          t = jj_consume_token(SLASH);
                  sb.append(t.image);
          break;
        case DESCENDENT_OR_SELF_SHORT:
          s4 = DescendantOrSelfShort();
                                                                     sb.append(s4);
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        s3 = RelativeOXPathLocationPath();
                                                                                                                        sb.append(s3);
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String DescendantOrSelfShort() throws ParseException {
 /*@bgen(jjtree) DescendantOrSelfShort */
 SimpleNode jjtn000 = new SimpleNode(JJTDESCENDANTORSELFSHORT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(DESCENDENT_OR_SELF_SHORT);
                                   jjtree.closeNodeScope(jjtn000, true);
                                   jjtc000 = false;
                                  {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathKleeneStar() throws ParseException {
 /*@bgen(jjtree) OXPathKleeneStar */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHKLEENESTAR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s3;
 Token t1;
 Token t2;
 Token t3;
 Token t4;
 Token t5;
 String s4;
    try {
      //Overload the Multiply operator for Kleene star
        t1 = jj_consume_token(BEGIN_KLEENE_STAR);
      s3 = OXPathPathSegment();
      t2 = jj_consume_token(CLOSE_PARAN);
                                                                      sb.append(t1.image); sb.append(s3); sb.append(t2.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        t3 = jj_consume_token(MULTIPLY);
                    sb.append(t3.image);
        break;
      case OPEN_CURLY:
        t4 = jj_consume_token(OPEN_CURLY);
        s4 = OXPathKleeneStarPredicate();
        t5 = jj_consume_token(CLOSE_CURLY);
                                                                       sb.append(t4.image); sb.append(s4); sb.append(t5.image);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathKleeneStarPredicate() throws ParseException {
 /*@bgen(jjtree) OXPathKleeneStarPredicate */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHKLEENESTARPREDICATE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    try {
      s1 = OXPathKleeneStarPredicateArg();
                                     sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        t = jj_consume_token(COMMA);
                sb.append(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS:
          s2 = OXPathKleeneStarPredicateArg();
                                       sb.append(s2);
          break;
        default:
          jj_la1[25] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathKleeneStarPredicateArg() throws ParseException {
 /*@bgen(jjtree) OXPathKleeneStarPredicateArg */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHKLEENESTARPREDICATEARG);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(DIGITS);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathStep() throws ParseException {
 /*@bgen(jjtree) OXPathStep */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHSTEP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s1;
 String s2;
 String s3;
 String s4;
 StringBuilder sb = new StringBuilder();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OXPATH_AXISNAME:
      case XPATH_FORWARD_AXISNAME:
      case XPATH_BACKWARD_AXISNAME:
      case NODE_TYPE:
      case NODE_TYPE_OXPATH:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case WILDCARD_BOUNDED:
      case QNAME:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OXPATH_AXISNAME:
        case XPATH_FORWARD_AXISNAME:
        case XPATH_BACKWARD_AXISNAME:
        case NODE_TYPE:
        case NODE_TYPE_OXPATH:
        case AT:
        case WILDCARD:
        case WILDCARD_BOUNDED:
        case QNAME:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OXPATH_AXISNAME:
          case XPATH_FORWARD_AXISNAME:
          case XPATH_BACKWARD_AXISNAME:
          case AT:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case XPATH_FORWARD_AXISNAME:
            case XPATH_BACKWARD_AXISNAME:
            case AT:
              s1 = XPathAxisSpecifier();
              break;
            case OXPATH_AXISNAME:
              s1 = OXPathAxisSpecifier();
              break;
            default:
              jj_la1[27] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
                                                                sb.append(s1);
            break;
          default:
            jj_la1[28] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NODE_TYPE:
          case WILDCARD:
          case WILDCARD_BOUNDED:
          case QNAME:
            s2 = XPathNodeTest();
            break;
          case NODE_TYPE_OXPATH:
            s2 = OXPathNodeTest();
            break;
          default:
            jj_la1[29] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                 sb.append(s2);
          break;
        case PERIOD:
        case PARENT_SHORT:
          s1 = AbbreviatedStep();
                        sb.append(s1);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPEN_OPTIONAL:
          case OPEN_BRACKET:
          case BEGIN_EXTRACT_MARK:
          case PERIOD_OP:
          case HASH:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_6;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PERIOD_OP:
          case HASH:
            s3 = OXPathNodeTestOp();
            break;
          case OPEN_BRACKET:
            s3 = XPathPredicate();
            break;
          case OPEN_OPTIONAL:
            s3 = OXPathOptionalPredicate();
            break;
          case BEGIN_EXTRACT_MARK:
            s3 = OXPathExtractionMarker();
            break;
          default:
            jj_la1[32] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                                                                                   sb.append(s3);
        }
        break;
      case VARIABLE_DEFAULT:
      case VARIABLE:
        s1 = VariableName();
                     sb.append(s1);
        break;
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case OPEN_CURLY:
        s1 = OXPathAction();
                     sb.append(s1);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
 {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathAxisSpecifier() throws ParseException {
 /*@bgen(jjtree) XPathAxisSpecifier */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHAXISSPECIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XPATH_FORWARD_AXISNAME:
        s = XPathForwardAxisName();
        break;
      case XPATH_BACKWARD_AXISNAME:
        s = XPathBackwardAxisName();
        break;
      case AT:
        s = XPathAbbreviatedAxisSpecifier();
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathAxisSpecifier() throws ParseException {
 /*@bgen(jjtree) #OXPathAxisSpecifier(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHAXISSPECIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = OXPathAxisName();
                       jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                       jjtc000 = false;
                      {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathForwardAxisName() throws ParseException {
 /*@bgen(jjtree) XPathForwardAxisName */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHFORWARDAXISNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(XPATH_FORWARD_AXISNAME);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathBackwardAxisName() throws ParseException {
 /*@bgen(jjtree) XPathBackwardAxisName */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHBACKWARDAXISNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(XPATH_BACKWARD_AXISNAME);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                 {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathAxisName() throws ParseException {
 /*@bgen(jjtree) OXPathAxisName */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHAXISNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(OXPATH_AXISNAME);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathAbbreviatedAxisSpecifier() throws ParseException {
 /*@bgen(jjtree) XPathAbbreviatedAxisSpecifier */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHABBREVIATEDAXISSPECIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(AT);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
            {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathNodeTest() throws ParseException {
 /*@bgen(jjtree) XPathNodeTest */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHNODETEST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s2;
 Token t1;
 Token t2;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WILDCARD:
      case WILDCARD_BOUNDED:
      case QNAME:
        s1 = XPathNameTest();
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,s1);}
        break;
      case NODE_TYPE:
        t1 = jj_consume_token(NODE_TYPE);
                      sb.append(t1.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOUBLE_QUOTE_STRING_PATH:
        case SINGLE_QUOTE_STRING_PATH:
          s1 = XPathLiteral();
                                                                 sb.append(s1);
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
        t2 = jj_consume_token(CLOSE_PARAN);
   sb.append(t2.image);
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                            {if (true) return process(jjtn000,sb.toString());}
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathNodeTest() throws ParseException {
 /*@bgen(jjtree) OXPathNodeTest */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHNODETEST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t1;
 Token t2;
    try {
      t1 = jj_consume_token(NODE_TYPE_OXPATH);
                             sb.append(t1.image);
      //  ( s1=XPathLiteral() {sb.append(s1);} )?
        t2 = jj_consume_token(CLOSE_PARAN);
                     sb.append(t2.image);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathNodeTestOp() throws ParseException {
 /*@bgen(jjtree) OXPathNodeTestOp */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHNODETESTOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s;
    try {
      s1 = OXPathNodeTestOper();
                           sb.append(s1);
      s = XPathQName();
                                                            jjtree.closeNodeScope(jjtn000, true);
                                                            jjtc000 = false;
                                                           sb.append(s); {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathNodeTestOper() throws ParseException {
 /*@bgen(jjtree) OXPathNodeTestOper */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHNODETESTOPER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD_OP:
        t = jj_consume_token(PERIOD_OP);
        break;
      case HASH:
        t = jj_consume_token(HASH);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathNameTest() throws ParseException {
 /*@bgen(jjtree) XPathNameTest */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHNAMETEST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
 String s;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WILDCARD:
        t = jj_consume_token(WILDCARD);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,t.image);}
        break;
      case WILDCARD_BOUNDED:
        t = jj_consume_token(WILDCARD_BOUNDED);
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                          {if (true) return process(jjtn000,t.image);}
        break;
      case QNAME:
        s = XPathQName();
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  {if (true) return process(jjtn000,s);}
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathQName() throws ParseException {
 /*@bgen(jjtree) XPathQName */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHQNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(QNAME);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//String XPathNCName() ://{Token t;}//{//  t=< NCNAME > {return process(jjtThis,t.image);}//}

//void XPathQName() ://{}//{//  < NCNAME > ( < COLON > < NCNAME > )?//}

//void XPathNodeType() ://{}//{//  < COMMENT > | < TEXT > | < PROCESSING_INSTRUCTION > | < NODE >//}
  final public String XPathLiteral() throws ParseException {
 /*@bgen(jjtree) XPathLiteral */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHLITERAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE_QUOTE_STRING_PATH:
        t = jj_consume_token(DOUBLE_QUOTE_STRING_PATH);
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                      {if (true) return process(jjtn000,t.image);}
        break;
      case SINGLE_QUOTE_STRING_PATH:
        t = jj_consume_token(SINGLE_QUOTE_STRING_PATH);
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                      {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//String OXPathNodeTest() #OXPathNodeTest(>1)://{String s;}//{//no semantic meaning to nodetype tests for OXPath additional axes////  XPathNameTest() | ( XPathNodeType() < OPEN_PARAN > ( XPathLiteral() ) ? <CLOSE_PARAN > )//  s=OXPathNameTest() {return process(jjtThis,s);}//}

//String OXPathNameTest() ://{Token t;// String s;}//{////  < WILDCARD > | ( XPathNCName() ( < COLON > ( < WILDCARD > | XPathNCName() ) )? )////< NAME_TEST >//  t=< WILDCARD > {return process(jjtThis,t.image);}//| t=< WILDCARD_BOUNDED > {return process(jjtThis,t.image);}//| s=XPathQName() {return process(jjtThis,s);}//}

//String AnyPredicate() #AnyPredicate(>1)://{StringBuilder sb = new StringBuilder();// Token t1;// String s;// Token t2;}//{//  t1=< OPEN_BRACKET > s=XPathPredicateExpr() t2=< CLOSE_BRACKET >//  {sb.append(t1.image); sb.append(s); sb.append(t2);//  return process(jjtThis,sb.toString());}
//}
  final public String XPathPredicate() throws ParseException {
 /*@bgen(jjtree) XPathPredicate */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHPREDICATE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s;
 Token t2;
    try {
      t1 = jj_consume_token(OPEN_BRACKET);
      s = XPathPredicateExpr();
      t2 = jj_consume_token(CLOSE_BRACKET);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   sb.append(t1.image); sb.append(s); sb.append(t2);
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathOptionalPredicate() throws ParseException {
 /*@bgen(jjtree) OXPathOptionalPredicate */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHOPTIONALPREDICATE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s;
 Token t2;
    try {
      t1 = jj_consume_token(OPEN_OPTIONAL);
      s = XPathPredicateExpr();
      t2 = jj_consume_token(CLOSE_BRACKET);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   sb.append(t1.image); sb.append(s); sb.append(t2);
  {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//String OXPathPredicate() ://{StringBuilder sb = new StringBuilder();// Token t1;// String s;// Token t2;}//{////  < OPEN_BRACKET > OXPathPredicateExpr() < CLOSE_BRACKET >//  t1=< OPEN_BRACKET > s=XPathPredicateExpr() t2=< CLOSE_BRACKET >//  {sb.append(t1.image); sb.append(s); sb.append(t2);//   return process(jjtThis,sb.toString());}//}
  final public String XPathPredicateExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPredicateExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHPREDICATEEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = XPathExpr();
                  jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                  jjtc000 = false;
                 {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathPredicateExpr() throws ParseException {
 /*@bgen(jjtree) OXPathPredicateExpr */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHPREDICATEEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s;
 Token t2;
    try {
      t1 = jj_consume_token(OPEN_BRACKET);
      s = XPathPredicateExpr();
      t2 = jj_consume_token(CLOSE_BRACKET);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   sb.append(t1.image); sb.append(s); sb.append(t2);
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//String OXPathAction() ://{StringBuilder sb = new StringBuilder();// Token t1;// String s1;// Token t2;// String s2;// Token t3;}//{//  t1=< OPEN_CURLY > {sb.append(t1.image);} (s1=OXPathAttributeDeclaration() t2=< EQUALS > {sb.append(s1); sb.append(t2.image);} )?//  s2=UnGroundedOXPathActionDeclaration() t3=< CLOSE_CURLY > {sb.append(s2); sb.append(t3.image); return process(jjtThis,sb.toString());}//}
  final public String OXPathAction() throws ParseException {
 /*@bgen(jjtree) #OXPathAction(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHACTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
        s = OXPathURLAction();
        break;
      case OPEN_CURLY:
        s = OXPathUserAction();
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathURLAction() throws ParseException {
 /*@bgen(jjtree) OXPathURLAction */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHURLACTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s;
 Token t2;
 Token t3;
 Token t4;
 String s1;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN_URL_IN_PATH:
        t1 = jj_consume_token(BEGIN_URL_IN_PATH);
        s = URLName();
        t2 = jj_consume_token(END_URL_IN_PATH);
    sb.append(t1.image);
    sb.append(s);
    sb.append(t2.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
          s1 = OXPathActionPred();
                            sb.append(s1);
          break;
        default:
          jj_la1[41] = jj_gen;
          ;
        }
        t3 = jj_consume_token(SLASH);
        t4 = jj_consume_token(CLOSE_CURLY);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    sb.append(t3.image);
    sb.append(t4.image);
    {if (true) return process(jjtn000,sb.toString());}
        break;
      case DOC_BEGIN:
        t1 = jj_consume_token(DOC_BEGIN);
        s = XPathLiteral();
    sb.append(t1.image);
    sb.append(s);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
          s1 = OXPathActionPred();
                            sb.append(s1);
          break;
        default:
          jj_la1[42] = jj_gen;
          ;
        }
        t2 = jj_consume_token(CLOSE_PARAN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    sb.append(t2.image);
    {if (true) return process(jjtn000,sb.toString());}
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathUserAction() throws ParseException {
 /*@bgen(jjtree) OXPathUserAction */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHUSERACTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s1;
 String s2;
 Token t2;
 String s3;
    try {
      t1 = jj_consume_token(OPEN_CURLY);
                     sb.append(t1.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGITS:
        s1 = UnGroundedOXPathActionPosition();
        break;
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        s1 = GroundedOXPathActionExplicit();
        break;
      case FOCUS:
      case CLICK:
      case DBLCLICK:
      case MOUSEDOWN:
      case MOUSEENTER:
      case MOUSEMOVE:
      case MOUSEOVER:
      case MOUSEOUT:
      case MOUSEUP:
      case WHEEL:
      case SUBMIT:
      case UNCLICK:
      case CHECK:
      case UNCHECK:
        s1 = OXPathActionKeyword();
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        s3 = OXPathActionPred();
                             sb.append(s3);
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH:
        s2 = OXPathAbsoluteActionSignal();
                                     sb.append(s2);
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      t2 = jj_consume_token(CLOSE_CURLY);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   sb.append(t2.image); {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathActionPred() throws ParseException {
 /*@bgen(jjtree) #OXPathActionPred(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHACTIONPRED);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s;
 Token t2;
    try {
      t1 = jj_consume_token(OPEN_BRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WAIT:
        s = OXPathActionWaitPred();
        break;
      case UNTIL:
        s = OXPathActionUntilPred();
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = jj_consume_token(CLOSE_BRACKET);
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
    sb.append(t1.image);
    sb.append(s);
    sb.append(t2.image);
    {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathActionWaitPred() throws ParseException {
 /*@bgen(jjtree) OXPathActionWaitPred */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHACTIONWAITPRED);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
 String s;
    try {
      t = jj_consume_token(WAIT);
      s = XPathNumber();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image+s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathActionUntilPred() throws ParseException {
 /*@bgen(jjtree) OXPathActionUntilPred */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHACTIONUNTILPRED);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
 String s;
    try {
      t = jj_consume_token(UNTIL);
      s = OXPathPathSegment();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image+s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//String OXPathAttributeDeclaration() ://{Token t;// String s;}//{//  t=< AT > s=XPathQName() {return process(jjtThis,(t.image+s));}//}
  final public String OXPathAbsoluteActionSignal() throws ParseException {
 /*@bgen(jjtree) OXPathAbsoluteActionSignal */
  SimpleNode jjtn000 = new SimpleNode(JJTOXPATHABSOLUTEACTIONSIGNAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SLASH);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String UnGroundedOXPathActionDeclaration() throws ParseException {
 /*@bgen(jjtree) UnGroundedOXPathActionDeclaration */
 SimpleNode jjtn000 = new SimpleNode(JJTUNGROUNDEDOXPATHACTIONDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGITS:
        s = UnGroundedOXPathActionPosition();
        break;
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        s = UnGroundedOXPathActionExplicit();
        break;
      case VARIABLE:
        s = UnGroundedOXPathActionVariable();
        break;
      case FOCUS:
      case CLICK:
      case DBLCLICK:
      case MOUSEDOWN:
      case MOUSEENTER:
      case MOUSEMOVE:
      case MOUSEOVER:
      case MOUSEOUT:
      case MOUSEUP:
      case WHEEL:
      case SUBMIT:
      case UNCLICK:
      case CHECK:
      case UNCHECK:
        s = OXPathActionKeyword();
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String UnGroundedOXPathActionPosition() throws ParseException {
 /*@bgen(jjtree) UnGroundedOXPathActionPosition */
 SimpleNode jjtn000 = new SimpleNode(JJTUNGROUNDEDOXPATHACTIONPOSITION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    try {
      s1 = GroundedOXPathActionPosition();
                                     sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        t = jj_consume_token(COMMA);
        s2 = UnGroundedOXPathActionPosition();
                                                     sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String GroundedOXPathActionPosition() throws ParseException {
 /*@bgen(jjtree) GroundedOXPathActionPosition */
 SimpleNode jjtn000 = new SimpleNode(JJTGROUNDEDOXPATHACTIONPOSITION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(DIGITS);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String UnGroundedOXPathActionExplicit() throws ParseException {
 /*@bgen(jjtree) UnGroundedOXPathActionExplicit */
 SimpleNode jjtn000 = new SimpleNode(JJTUNGROUNDEDOXPATHACTIONEXPLICIT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    try {
      s1 = GroundedOXPathActionExplicit();
                                     sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        t = jj_consume_token(COMMA);
        s2 = UnGroundedOXPathActionExplicit();
                                                     sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String GroundedOXPathActionExplicit() throws ParseException {
 /*@bgen(jjtree) GroundedOXPathActionExplicit */
 SimpleNode jjtn000 = new SimpleNode(JJTGROUNDEDOXPATHACTIONEXPLICIT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = XPathLiteral();
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String UnGroundedOXPathActionVariable() throws ParseException {
 /*@bgen(jjtree) UnGroundedOXPathActionVariable */
 SimpleNode jjtn000 = new SimpleNode(JJTUNGROUNDEDOXPATHACTIONVARIABLE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(VARIABLE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//String UnGroundedOXPathActionReference() ://{StringBuilder sb = new StringBuilder();// String s1;// Token t1;// Token t2;// String s2;// Token t3;}//{//NCName includes <PERIOD > token//  (( s1=XPathQName() {sb.append(s1);}//  ( t1=< COMMA > t2=< FUNCTION_NAME > {sb.append(t1.image); sb.append(t2.image);}//  (s2=OXPathActionReferenceDependencyList() {sb.append(s2);} )?//  t3=< CLOSE_PARAN > {sb.append(t3.image);} )?)//| t1=< FUNCTION_NAME > s1=OXPathActionAttributes() t2=< CLOSE_PARAN > {sb.append(t1.image); sb.append(s1); sb.append(t2.image);})//  {return process(jjtThis,sb.toString());}//}////String OXPathActionAttributes() ://{StringBuilder sb = new StringBuilder();// String s1;// Token t;// String s2;}//{//  s1=XPathLiteral() {sb.append(s1);}//  [ t=< COMMA > s2=OXPathActionAttributes() {sb.append(t.image); sb.append(s2);}]//  {return process(jjtThis,sb.toString());}//}////String OXPathActionReferenceDependencyList() ://{StringBuilder sb = new StringBuilder();// String s1;// Token t;// String s2;}//{//  s1=OXPathActionReferenceDependency() {sb.append(s1);}//  [ t=< COMMA > s2=OXPathActionReferenceDependencyList() {sb.append(t.image); sb.append(s2);} ]//  {return process(jjtThis,sb.toString());}//}////String OXPathActionReferenceDependency() ://{String s;}//{//  s=XPathQName() {return process(jjtThis,s);}//}
  final public String OXPathActionKeyword() throws ParseException {
 /*@bgen(jjtree) OXPathActionKeyword */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHACTIONKEYWORD);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOCUS:
        t = jj_consume_token(FOCUS);
        break;
      case CLICK:
        t = jj_consume_token(CLICK);
        break;
      case DBLCLICK:
        t = jj_consume_token(DBLCLICK);
        break;
      case MOUSEDOWN:
        t = jj_consume_token(MOUSEDOWN);
        break;
      case MOUSEENTER:
        t = jj_consume_token(MOUSEENTER);
        break;
      case MOUSEMOVE:
        t = jj_consume_token(MOUSEMOVE);
        break;
      case MOUSEOVER:
        t = jj_consume_token(MOUSEOVER);
        break;
      case MOUSEOUT:
        t = jj_consume_token(MOUSEOUT);
        break;
      case MOUSEUP:
        t = jj_consume_token(MOUSEUP);
        break;
      case WHEEL:
        t = jj_consume_token(WHEEL);
        break;
      case SUBMIT:
        t = jj_consume_token(SUBMIT);
        break;
      case UNCLICK:
        t = jj_consume_token(UNCLICK);
        break;
      case CHECK:
        t = jj_consume_token(CHECK);
        break;
      case UNCHECK:
        t = jj_consume_token(UNCHECK);
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathExtractionMarker() throws ParseException {
 /*@bgen(jjtree) OXPathExtractionMarker */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHEXTRACTIONMARKER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s1;
 Token t2;
 String s2;
 Token t3;
    try {
      t1 = jj_consume_token(BEGIN_EXTRACT_MARK);
                             sb.append(t1.image);
      s1 = OXPathExtractionName();
                             sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        t2 = jj_consume_token(EQUALS);
        s2 = OXPathExtractionValue();
                                             sb.append(t2.image); sb.append(s2);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END_EXTRACT_MARK:
        t3 = jj_consume_token(END_EXTRACT_MARK);
        break;
      case GREATER:
        t3 = jj_consume_token(GREATER);
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                              sb.append(t3.image);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathExtractionName() throws ParseException {
 /*@bgen(jjtree) OXPathExtractionName */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHEXTRACTIONNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(QNAME);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String OXPathExtractionValue() throws ParseException {
 /*@bgen(jjtree) #OXPathExtractionValue(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTOXPATHEXTRACTIONVALUE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = XPathPrimaryExpr();
                         jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                         jjtc000 = false;
                        {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathExpr() throws ParseException {
 /*@bgen(jjtree) #XPathExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = XPathOrExpr();
                    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                    jjtc000 = false;
                   {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathOrExpr() throws ParseException {
 /*@bgen(jjtree) #XPathOrExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHOREXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    try {
      s1 = XPathAndExpr();
                     sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        t = jj_consume_token(OR);
        s2 = XPathOrExpr();
                                                                  sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathAndExpr() throws ParseException {
 /*@bgen(jjtree) #XPathAndExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHANDEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
String s1;
Token t;
String s2;
    try {
      s1 = XPathEqualityExpr();
                          sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        t = jj_consume_token(AND);
        s2 = XPathAndExpr();
                                                                         sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathEqualityExpr() throws ParseException {
 /*@bgen(jjtree) #XPathEqualityExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHEQUALITYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s;
 String s2;
    try {
      s1 = XPathRelationalExpr();
                            sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOTEQUAL:
      case EQUALS:
      case WORD_TEST:
      case CONTAINS:
        s = XPathEqualityExprOp();
                              sb.append(s);
        s2 = XPathEqualityExpr();
                             sb.append(s2);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathEqualityExprOp() throws ParseException {
 /*@bgen(jjtree) XPathEqualityExprOp */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHEQUALITYEXPROP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        t = jj_consume_token(EQUALS);
        break;
      case NOTEQUAL:
        t = jj_consume_token(NOTEQUAL);
        break;
      case WORD_TEST:
        t = jj_consume_token(WORD_TEST);
        break;
      case CONTAINS:
        t = jj_consume_token(CONTAINS);
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathRelationalExpr() throws ParseException {
 /*@bgen(jjtree) #XPathRelationalExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHRELATIONALEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s;
 String s2;
    try {
      //here, right-associative, rather than left-associative in XPath standard
        s1 = XPathAdditiveExpr();
                          sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESSTE:
      case LESS:
      case GREATERTE:
      case GREATER:
        s = XPathRelationalExprOp();
                               sb.append(s);
        s2 = XPathRelationalExpr();
                              sb.append(s2);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathRelationalExprOp() throws ParseException {
 /*@bgen(jjtree) XPathRelationalExprOp */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHRELATIONALEXPROP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GREATER:
        t = jj_consume_token(GREATER);
        break;
      case LESS:
        t = jj_consume_token(LESS);
        break;
      case GREATERTE:
        t = jj_consume_token(GREATERTE);
        break;
      case LESSTE:
        t = jj_consume_token(LESSTE);
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathAdditiveExpr() throws ParseException {
 /*@bgen(jjtree) #XPathAdditiveExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHADDITIVEEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s;
 String s2;
    try {
      s1 = XPathMultiplicativeExpr();
                                sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        s = XPathAdditiveExprOp();
                              sb.append(s);
        s2 = XPathAdditiveExpr();
                             sb.append(s2);
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathAdditiveExprOp() throws ParseException {
 /*@bgen(jjtree) XPathAdditiveExprOp */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHADDITIVEEXPROP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathMultiplicativeExpr() throws ParseException {
 /*@bgen(jjtree) #XPathMultiplicativeExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHMULTIPLICATIVEEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s;
 String s2;
    try {
      s1 = XPathUnaryExpr();
                       sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOD:
      case DIV:
      case MULTIPLY:
        s = XPathMultiplicativeOp();
                               sb.append(s);
        s2 = XPathMultiplicativeExpr();
                                  sb.append(s2);
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathMultiplicativeOp() throws ParseException {
 /*@bgen(jjtree) XPathMultiplicativeOp */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHMULTIPLICATIVEOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        t = jj_consume_token(MULTIPLY);
        break;
      case DIV:
        t = jj_consume_token(DIV);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathUnaryExpr() throws ParseException {
 /*@bgen(jjtree) #XPathUnaryExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHUNARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s;
 String s1;
    try {
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          ;
          break;
        default:
          jj_la1[64] = jj_gen;
          break label_7;
        }
        s1 = XPathUnaryExprOp();
                           sb.append(s1);
      }
      s = XPathUnionExpr();
                                                                  sb.append(s);
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathUnaryExprOp() throws ParseException {
 /*@bgen(jjtree) XPathUnaryExprOp */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHUNARYEXPROP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(MINUS);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathPrimaryExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPrimaryExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHPRIMARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 Token t1;
 String s;
 Token t2;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PARAN:
        t1 = jj_consume_token(OPEN_PARAN);
        s = XPathExpr();
        t2 = jj_consume_token(CLOSE_PARAN);
                                                        sb.append(t1.image); sb.append(s); sb.append(t2.image);
        break;
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        s = XPathLiteral();
                    sb.append(s);
        break;
      case NUMBER:
      case DIGITS:
        s = XPathNumber();
                   sb.append(s);
        break;
      case FUNCTION_NAME:
        s = XPathFunctionCall();
                         sb.append(s);
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
  jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
  jjtc000 = false;
 {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathNumber() throws ParseException {
 /*@bgen(jjtree) XPathNumber */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        t = jj_consume_token(NUMBER);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                {if (true) return process(jjtn000,t.image);}
        break;
      case DIGITS:
        t = jj_consume_token(DIGITS);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathFunctionCall() throws ParseException {
 /*@bgen(jjtree) XPathFunctionCall */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHFUNCTIONCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s3;
 String s1;
 Token t2;
 String s2;
 Token t3;
    try {
      s3 = XPathFunctionCallName();
                              sb.append(s3);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_DEFAULT:
      case DOC_BEGIN:
      case OPEN_PARAN:
      case BEGIN_URL_IN_PATH:
      case OPEN_CURLY:
      case NUMBER:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case OXPATH_AXISNAME:
      case XPATH_FORWARD_AXISNAME:
      case XPATH_BACKWARD_AXISNAME:
      case NODE_TYPE:
      case NODE_TYPE_OXPATH:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case FUNCTION_NAME:
      case VARIABLE:
      case MINUS:
      case WILDCARD:
      case WILDCARD_BOUNDED:
      case QNAME:
      case DIGITS:
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        s1 = XPathArgument();
                        sb.append(s1);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[67] = jj_gen;
            break label_8;
          }
          t2 = jj_consume_token(COMMA);
          s2 = XPathArgument();
                                                                           sb.append(t2.image); sb.append(s2);
        }
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
      t3 = jj_consume_token(CLOSE_PARAN);
                                                                                                                                          sb.append(t3.image);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathFunctionCallName() throws ParseException {
 /*@bgen(jjtree) XPathFunctionCallName */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHFUNCTIONCALLNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FUNCTION_NAME);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,t.image);}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathArgument() throws ParseException {
 /*@bgen(jjtree) #XPathArgument(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHARGUMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = XPathExpr();
                  jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                  jjtc000 = false;
                 {if (true) return process(jjtn000,s);}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathUnionExpr() throws ParseException {
 /*@bgen(jjtree) #XPathUnionExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHUNIONEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    try {
      s1 = XPathPathExpr();
                      sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
        t = jj_consume_token(UNION);
        s2 = XPathUnionExpr();
                                                                         sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathPathExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPathExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHPATHEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
 String s3;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_DEFAULT:
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case OPEN_CURLY:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case OXPATH_AXISNAME:
      case XPATH_FORWARD_AXISNAME:
      case XPATH_BACKWARD_AXISNAME:
      case NODE_TYPE:
      case NODE_TYPE_OXPATH:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case VARIABLE:
      case WILDCARD:
      case WILDCARD_BOUNDED:
      case QNAME:
        s1 = OXPathPathSegment();
                           jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                           jjtc000 = false;
                          {if (true) return process(jjtn000,s1);}
        break;
      case OPEN_PARAN:
      case NUMBER:
      case FUNCTION_NAME:
      case DIGITS:
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        s1 = XPathFilterExpr();
                        sb.append(s1);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SLASH:
            t = jj_consume_token(SLASH);
                                                         sb.append(t.image);
            break;
          case DESCENDENT_OR_SELF_SHORT:
            s3 = DescendantOrSelfShort();
                                                                                                            sb.append(s3);
            break;
          default:
            jj_la1[70] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          s2 = RelativeOXPathLocationPath();
                                                                           sb.append(s2);
          break;
        default:
          jj_la1[71] = jj_gen;
          ;
        }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathFilterExpr() throws ParseException {
 /*@bgen(jjtree) #XPathFilterExpr(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTXPATHFILTEREXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
 String s1;
 String s2;
    try {
      s1 = XPathPrimaryExpr();
                         sb.append(s1);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
          ;
          break;
        default:
          jj_la1[73] = jj_gen;
          break label_9;
        }
        s2 = XPathPredicate();
                                                                sb.append(s2);
      }
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
   {if (true) return process(jjtn000,sb.toString());}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String AbbreviatedAbsoluteOXPathLocationPath() throws ParseException {
 /*@bgen(jjtree) AbbreviatedAbsoluteOXPathLocationPath */
 SimpleNode jjtn000 = new SimpleNode(JJTABBREVIATEDABSOLUTEOXPATHLOCATIONPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s1;
 String s;
    try {
      s1 = DescendantOrSelfShort();
      s = RelativeOXPathLocationPath();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return process(jjtn000,(s1+s));}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//void AbbreviatedRelativeOXPathLocationPath() ://{}//{//here, w3c grammar says second non-terminal is step, meaning only last step is DESCENDENT-OR-SELF abbreviation; change//  OXPathStep() < DESCENDENT_OR_SELF_SHORT > RelativeOXPathLocationPath()//}
  final public String AbbreviatedStep() throws ParseException {
 /*@bgen(jjtree) AbbreviatedStep */
 SimpleNode jjtn000 = new SimpleNode(JJTABBREVIATEDSTEP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        t = jj_consume_token(PERIOD);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                {if (true) return process(jjtn000,t.image);}
        break;
      case PARENT_SHORT:
        t = jj_consume_token(PARENT_SHORT);
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                      {if (true) return process(jjtn000,t.image);}
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

//void CommonAncestorDeclaration() ://{}//{//  < COMMONANCESTOR > < EQUALS > ScraperPath() < ENDLINE_XQ >//}
  final public void ScrapeDeclaration() throws ParseException {
 /*@bgen(jjtree) ScrapeDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTSCRAPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ScraperName();
      jj_consume_token(EQUALS_DEFAULT);
      ScraperPath();
      jj_consume_token(ENDLINE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ScraperName() throws ParseException {
 /*@bgen(jjtree) ScraperName */
 SimpleNode jjtn000 = new SimpleNode(JJTSCRAPERNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(QNAME_DEFAULT);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       process(jjtn000,t.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ScraperPath() throws ParseException {
 /*@bgen(jjtree) #ScraperPath(> 1) */
 SimpleNode jjtn000 = new SimpleNode(JJTSCRAPERPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
    try {
      s = XPathUnionExpr();
                       jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
                       jjtc000 = false;
                      process(jjtn000,s);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  /** Generated Token Manager. */
  public OXPathScripterTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[75];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x100,0x2c0,0x2c0,0x100,0x400,0x0,0x20000000,0x40000000,0x0,0x0,0x80000006,0x80000006,0x80000006,0x80000000,0x6,0x0,0x20000000,0x80000006,0x200,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7ffe000,0x0,0x0,0x0,0x7ffe000,0x0,0x0,0x7ffe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x200,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x6000,0x0,0x0,0x0,0xe000,0xffff,0xffff,0xffff,0xdf,0x1f00,0x8000,0x0,0xffff,0x0,0x3040000,0xa3040000,0x40000000,0xa0000000,0xa0000000,0x2000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x600000,0x600000,0x3040000,0x0,0x0,0x0,0x0,0x0,0x0,0x3040000,0x400000,0x400000,0x1040000,0x0,0x400000,0x80000000,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10080000,0x10000000,0x8000000,0xb30c0000,0x0,0xa0000000,0xa0000000,0xb30c0000,0x400000,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x800,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0xbee,0xbee,0x0,0x0,0x0,0x20000,0x0,0x0,0x20e,0x20e,0x60,0x3ee,0x18000001,0x18000001,0xbee,0x20c,0x0,0x20,0x18000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x4000000,0x1001000,0x4000,0x2000,0x66000000,0x66000000,0x1e00000,0x1e00000,0x180000,0x180000,0x38000,0x38000,0x100000,0x400,0x0,0x0,0x100fee,0x40000,0x0,0x0,0xfee,0x0,0x180,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x700,0x700,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x700,0x700,0x0,0x0,0x700,0x0,0x90000,0x700,0x0,0x700,0x90000,0x0,0x0,0x0,0x0,0x94000,0x0,0x0,0x60,0x94000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x94000,0x4000,0x0,0x94700,0x0,0x0,0x0,0x94700,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public OXPathScripter(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public OXPathScripter(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new OXPathScripterTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public OXPathScripter(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OXPathScripterTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public OXPathScripter(OXPathScripterTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(OXPathScripterTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[117];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 75; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 117; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
